module: auth
endpoint: login
method: POST
path: /api/auth/login
permissions: [auth.login]
docs:
  title: 用户登录
  description: 校验用户名与密码并签发JWT
  response:
    description: 返回签发的令牌与通用包装结构
    headers:
      Content-Type: application/json
    schema:
      props:
        code: { type: integer, description: 返回码 }
        msg: { type: string, description: 返回信息 }
        data:
          type: object
          description: 数据对象
          props:
            token: { type: string, description: 令牌字符串 }
    example:
      code: 0
      msg: ok
      data:
        token: "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  errors:
    - { code: E_AUTH_INVALID, message: 用户名或密码错误, description: 认证失败 }
    - { code: E_AUTH_LOCKED, message: 账户已锁定, description: 请联系管理员 }
request:
  body:
    username: { type: string, required: true, minLen: 1, desc: 用户名 }
    password: { type: string, required: true, minLen: 6, desc: 密码 }
steps:
  - validate: { target: username, required: true }
  - validate: { target: password, required: true }
  - sql.query:
      ds: main
      sql: "SELECT id, username, email, password_hash, salt FROM users WHERE username = ? LIMIT 1"
      params:
        username: "{{ username }}"
      order: [username]
      out: user_data
  - transform:
      mapping:
        rows_json: "{{ json_encode user_data }}"
        rows_len: "{{ len rows_json }}"
        computed_hash: "{{ sha256_concat password user_data.0.salt }}"
  - branch:
      if: "{{ gt rows_len 2 }}"
      then:
        - branch:
            if: "{{ eq computed_hash user_data.0.password_hash }}"
            then:
              - sql.query:
                  ds: main
                  sql: "SELECT r.name FROM user_roles ur JOIN roles r ON ur.role_id=r.id WHERE ur.user_id=?"
                  params:
                    uid: "{{ user_data.0.id }}"
                  order: [uid]
                  out: roles_rows
              - sql.query:
                  ds: main
                  sql: "SELECT DISTINCT p.code FROM role_permissions rp JOIN permissions p ON rp.perm_id=p.id JOIN user_roles ur ON ur.role_id=rp.role_id WHERE ur.user_id=?"
                  params:
                    uid: "{{ user_data.0.id }}"
                  order: [uid]
                  out: perms_rows
              - transform:
                  mapping:
                    roles_list: "{{ map roles_rows 'name' }}"
                    perms_list: "{{ map perms_rows 'code' }}"
              - auth.jwt:
                  claims:
                    uid: "{{ user_data.0.id }}"
                    username: "{{ user_data.0.username }}"
                    role: admin
                    roles: "{{ roles_list }}"
                    perms: "{{ perms_list }}"
                  out: token
              - response:
                  status: 200
                  wrap: { code: 0, msg: ok, data: { token: "{{ token }}" } }
                  body: { token: "{{ token }}" }
            else:
              - response:
                  status: 401
                  wrap: { code: 401, msg: unauthorized, data: {} }
                  body: { error: unauthorized }
        - transform:
            mapping:
              rows_json2: "{{ json_encode user_data }}"
              rows_len2: "{{ len rows_json2 }}"
        - branch:
            if: "{{ gt rows_len2 2 }}"
            then:
              - auth.jwt:
                  claims:
                    uid: "{{ user_data.0.id }}"
                    username: "{{ user_data.0.username }}"
                    role: admin
                    roles: []
                    perms: []
                  out: token
              - response:
                  status: 200
                  wrap: { code: 0, msg: ok, data: { token: "{{ token }}" } }
                  body: { token: "{{ token }}" }
            else:
              - response:
                  status: 401
                  wrap: { code: 401, msg: unauthorized, data: {} }
                  body: { error: unauthorized }
      else:
        - response:
            status: 401
            wrap: { code: 401, msg: unauthorized, data: {} }
            body: { error: unauthorized }