# 插件能力与编写指南

## 配置能力总览（零代码）
- 注册表（`configs/project.yaml` → `plugins.registry`）：声明插件二进制、实例数、超时、队列与函数列表；支持环境注入。
- 调用步骤（`plugin.call`）：在接口中以配置调用插件函数，支持重试与断路器回退。
- 运维步骤（`plugins.*`）：查询状态、控制启用禁用、动态添加/移除/重启/启动/停止插件。
- 分析与文档：`admin.plugins_usage` 输出插件使用与端点关联，便于治理。

## 注册表字段
```yaml
plugins:
  enabled: true
  runtime: goproc
  registry:
    - name: string_reverse                 # 插件名（接口中使用）
      executable:
        windows: plugins/string_reverse.exe
        unix:    ./plugins/string_reverse
      instances: 1                          # 实例数（并发池）
      timeout:   300ms                      # 调用超时（默认 300ms）
      queueSize: 1024                       # 并发队列规模（用于系统MaxConcurrentCalls）
      functions: ["reverse"]               # 暴露的函数列表
      env:        { PLUGIN_MODE: ${PLUGIN_MODE:prod} }   # 传入插件进程的环境键值
      envFrom:    ["*"]                                # 从当前进程环境选择传入（"*" 为全部）
```

## 在接口中调用插件
```yaml
steps:
  - plugin.call:
      plugin:   string_reverse
      function: reverse
      params:   { text: "{{ body.text }}" }
      retry:    1
      backoff:  300
      circuit:  { key: "plugin.rev", threshold: 3, openMs: 30000, fallback: "ERR" }
      out:      reversed
  - response: { status: 200, body: "{{ reversed }}" }
```
- `retry/backoff`：失败重试与退避间隔（毫秒）
- `circuit`：断路器（`threshold` 连续失败次数后打开，`openMs` 内直接返回 `fallback`；成功后复位）

## 插件运维（步骤）
```yaml
- plugins.status:  { out: plugins }
- plugins.control: { action: enable, names: [string_reverse], enabled: true }
- plugins.add:
    name: demo
    executable: { windows: plugins/demo.exe, unix: ./plugins/demo }
    instances: 1
    timeout: 300ms
    queueSize: 1024
    functions: ["hello", "echo"]
- plugins.remove:  { names: [demo] }
- plugins.restart: { names: [string_reverse] }
- plugins.stop:    { names: [string_reverse] }
- plugins.start:   { names: [string_reverse] }
- admin.plugins_usage: { out: usage }
```

## 环境变量与 .env
- 启动时加载 `.env` 与 `configs/.env`；系统环境优先级最高。
- 注册表支持 `env`（显式键值）与 `envFrom`（选择性传入或 `"*"` 全部）。
- 插件进程可用 `os.Getenv("KEY")` / 等价方法读取环境变量。

## 插件编写（Go 示例）
- 建议使用 `third_party/goproc` 的 Go SDK。参考：`third_party/goproc/docs/go_sdk_usage.md`
- 详细API参考和示例请查看SDK文档：
  - Go SDK: `third_party/goproc/docs/go_sdk_usage.md`
  - Node.js SDK: `third_party/goproc/docs/nodejs_sdk_usage.md`
  - Python SDK: `third_party/goproc/docs/python_sdk_usage.md`
```go
package main
import (
  "fmt"
  "log"
  "os"
  sdk "github.com/hoonfeng/goproc/sdk"
)
func reverse(params map[string]interface{}) (interface{}, error) {
  s, _ := params["text"].(string)
  r := []rune(s)
  for i,j := 0,len(r)-1; i<j; i,j=i+1,j-1 { r[i], r[j] = r[j], r[i] }
  mode := os.Getenv("PLUGIN_MODE") // 从环境读取模式 / read mode from env
  return map[string]interface{}{"text": string(r), "mode": mode}, nil
}
func main(){
  if err := sdk.RegisterFunction("reverse", reverse); err != nil { log.Fatal(err) }
  if err := sdk.Start(); err != nil { log.Fatal(err) }
  sdk.Wait()
}
```
- 编译：
  - Windows：`go build -o plugins/string_reverse.exe`
  - Unix：`GOOS=linux GOARCH=amd64 go build -o plugins/string_reverse`
- 在注册表 `functions` 中声明 `reverse`，并在接口中使用 `plugin.call` 调用。

## 插件编写（Node/Python 概览）
- 参考 `third_party/goproc/docs/nodejs_sdk_usage.md` 与 `third_party/goproc/docs/python_sdk_usage.md`；SDK已提供示例与通信封装。
- 关键点：按 SDK 接口注册函数，进程常驻，SDK负责通信；函数签名接收 `params`，返回结构化结果。

## 最佳实践
- 明确函数契约：参数名与类型在接口配置 `params` 中清晰声明。
- 使用 `env/envFrom` 管理密钥与配置；避免将敏感值硬编码在注册表中。
- 为关键调用配置 `retry/backoff` 与 `circuit`；插件异常时可快速回退。
- 通过 `admin.plugins_usage` 审视插件与端点关系，便于治理与迁移。