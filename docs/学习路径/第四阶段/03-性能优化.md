# 性能优化与测试

## 性能测试策略

### 集成测试脚本

创建PowerShell测试脚本覆盖关键场景：

```powershell
# test_api.ps1 - 全面的API性能测试脚本

$baseUrl = "http://localhost:8080"
$jwtToken = "your-jwt-token-here"
$apiKey = "your-api-key-here"
$apiSecret = "your-api-secret-here"

# 1. JWT认证测试
Write-Host "测试JWT认证接口..."
$jwtResponse = Invoke-RestMethod -Uri "$baseUrl/api/auth/login" -Method Post -Body (@{
    username = "admin"
    password = "admin123"
} | ConvertTo-Json) -ContentType "application/json"
Write-Host "JWT登录成功: $($jwtResponse | ConvertTo-Json -Compress)"

# 2. API Key + HMAC签名测试
Write-Host "测试API Key + HMAC接口..."
$timestamp = [int64]((Get-Date).ToUniversalTime() - (Get-Date "1970-01-01")).TotalSeconds
$nonce = [Guid]::NewGuid().ToString()
$body = @{ query = "test" } | ConvertTo-Json -Compress
$bodyHash = (Get-FileHash -Algorithm SHA256 -InputStream ([IO.MemoryStream]::new([Text.Encoding]::UTF8.GetBytes($body)))).Hash.ToLower()

$signatureString = "$timestamp$nonce$bodyHash"
$hmac = New-Object System.Security.Cryptography.HMACSHA256
$hmac.Key = [Text.Encoding]::UTF8.GetBytes($apiSecret)
$signature = [Convert]::ToBase64String($hmac.ComputeHash([Text.Encoding]::UTF8.GetBytes($signatureString)))

$headers = @{
    "X-Api-Key" = $apiKey
    "X-Timestamp" = $timestamp
    "X-Nonce" = $nonce
    "X-Signature" = $signature
    "X-Body-Hash" = $bodyHash
}

$hmacResponse = Invoke-RestMethod -Uri "$baseUrl/api/search" -Method Post -Headers $headers -Body $body -ContentType "application/json"
Write-Host "HMAC接口成功: $($hmacResponse | ConvertTo-Json -Compress)"

# 3. 限流测试
Write-Host "测试限流功能..."
$rateLimitResponses = @()
for ($i = 1; $i -le 15; $i++) {
    try {
        $response = Invoke-WebRequest -Uri "$baseUrl/api/rate-limited" -Method Get -Headers @{ Authorization = "Bearer $jwtToken" } -ErrorAction Stop
        $rateLimitResponses += @{ Attempt = $i; Status = $response.StatusCode; Latency = $response.Headers["X-Response-Time"] }
    } catch {
        $rateLimitResponses += @{ Attempt = $i; Status = $_.Exception.Response.StatusCode; Error = $_.Exception.Message }
    }
    Start-Sleep -Milliseconds 100
}
Write-Host "限流测试结果: $($rateLimitResponses | ConvertTo-Json -Compress)"

# 4. 事务测试
Write-Host "测试事务功能..."
$transactionData = @{
    from_user_id = 1
    to_user_id = 2
    amount = 100.50
}
$transactionResponse = Invoke-RestMethod -Uri "$baseUrl/api/transfer" -Method Post -Headers @{ Authorization = "Bearer $jwtToken" } -Body ($transactionData | ConvertTo-Json) -ContentType "application/json"
Write-Host "事务测试成功: $($transactionResponse | ConvertTo-Json -Compress)"

# 5. 文件上传测试
Write-Host "测试文件上传..."
$testFile = [System.IO.Path]::GetTempFileName() + ".txt"
[System.IO.File]::WriteAllText($testFile, "测试文件内容")

$form = @{
    title = "测试文件"
    description = "性能测试用的文件"
}

$fileBytes = [System.IO.File]::ReadAllBytes($testFile)
$fileContent = [System.Net.Http.ByteArrayContent]::new($fileBytes)
$fileContent.Headers.ContentType = [System.Net.Http.Headers.MediaTypeHeaderValue]::Parse("text/plain")

$multipartContent = [System.Net.Http.MultipartFormDataContent]::new()
$multipartContent.Add([System.Net.Http.StringContent]::new($form.title), "title")
$multipartContent.Add([System.Net.Http.StringContent]::new($form.description), "description")
$multipartContent.Add($fileContent, "file", "test.txt")

$uploadResponse = Invoke-RestMethod -Uri "$baseUrl/api/upload" -Method Post -Headers @{ Authorization = "Bearer $jwtToken" } -Body $multipartContent -ContentType "multipart/form-data"
Write-Host "文件上传成功: $($uploadResponse | ConvertTo-Json -Compress)"

# 清理临时文件
Remove-Item $testFile -ErrorAction SilentlyContinue

Write-Host "所有性能测试完成!"
```

### 负载测试脚本

```powershell
# load_test.ps1 - 负载测试脚本

$baseUrl = "http://localhost:8080"
$jwtToken = "your-jwt-token-here"
$concurrentUsers = 10
$requestsPerUser = 100

$totalRequests = $concurrentUsers * $requestsPerUser
Write-Host "开始负载测试: $concurrentUsers 并发用户, 每个 $requestsPerUser 请求"

$results = @()
$stopwatch = [System.Diagnostics.Stopwatch]::StartNew()

# 创建并发任务
$jobs = @()
for ($i = 1; $i -le $concurrentUsers; $i++) {
    $job = Start-Job -ScriptBlock {
        param($baseUrl, $jwtToken, $requestsPerUser, $userId)
        
        $userResults = @()
        for ($j = 1; $j -le $requestsPerUser; $j++) {
            $requestStopwatch = [System.Diagnostics.Stopwatch]::StartNew()
            
            try {
                $response = Invoke-WebRequest -Uri "$baseUrl/api/users/$userId" -Method Get -Headers @{ 
                    Authorization = "Bearer $jwtToken"
                } -ErrorAction Stop
                
                $userResults += @{
                    Success = $true
                    StatusCode = $response.StatusCode
                    LatencyMs = $requestStopwatch.ElapsedMilliseconds
                    Timestamp = Get-Date
                }
            } catch {
                $userResults += @{
                    Success = $false
                    StatusCode = $_.Exception.Response.StatusCode
                    Error = $_.Exception.Message
                    LatencyMs = $requestStopwatch.ElapsedMilliseconds
                    Timestamp = Get-Date
                }
            }
            
            $requestStopwatch.Stop()
            Start-Sleep -Milliseconds (Get-Random -Minimum 10 -Maximum 100)
        }
        
        return $userResults
    } -ArgumentList $baseUrl, $jwtToken, $requestsPerUser, $i
    
    $jobs += $job
}

# 等待所有任务完成
$jobResults = $jobs | Wait-Job | Receive-Job

$stopwatch.Stop()

# 汇总结果
$allResults = $jobResults | ForEach-Object { $_ }

$successCount = ($allResults | Where-Object { $_.Success -eq $true }).Count
$errorCount = ($allResults | Where-Object { $_.Success -eq $false }).Count
$totalLatency = ($allResults | Measure-Object -Property LatencyMs -Sum).Sum
$avgLatency = $totalLatency / $totalRequests
$rps = $totalRequests / $stopwatch.Elapsed.TotalSeconds

Write-Host "负载测试完成!"
Write-Host "总时间: $($stopwatch.Elapsed.ToString())"
Write-Host "总请求数: $totalRequests"
Write-Host "成功: $successCount"
Write-Host "失败: $errorCount"
Write-Host "成功率: $(($successCount / $totalRequests * 100).ToString('N2'))%"
Write-Host "平均延迟: $(($avgLatency).ToString('N2')) ms"
Write-Host "RPS: $(($rps).ToString('N2'))"

# 清理作业
$jobs | Remove-Job -Force
```

## 性能优化技巧

### SQL 查询优化

#### 启用SQL日志调试
```yaml
steps:
  - sql.query:
      ds: main
      sql: "SELECT * FROM users WHERE status = ? AND created_at > ?"
      params: 
        status: "active"
        created_at: "{{ sub_days(now, 30) }}"
      out: active_users
  
  - response:
      status: 200
      body: 
        users: "{{ active_users }}"
        sql_log: "{{ ctx.vars.sql_log }}"  # 查看SQL执行详情
```

#### 查询性能分析
```yaml
# 使用EXPLAIN分析查询性能
- plugin.call:
    plugin: db_analyzer
    function: explain
    params: 
      sql: "SELECT * FROM large_table WHERE condition = ?"
      params: { condition: "value" }
    out: explain_result
```

### 缓存优化策略

#### 多级缓存配置
```yaml
steps:
  # 第一级：内存缓存
  - cache.get:
      key: "user:{{ path.id }}"
      out: cached_user
  
  - branch:
      if: "{{ cached_user }}"
      then:
        - response:
            status: 200
            body: "{{ cached_user }}"
  
  # 第二级：Redis缓存
  - kv.get:
      ds: redis_cache
      key: "user:{{ path.id }}"
      out: redis_user
  
  - branch:
      if: "{{ redis_user }}"
      then:
        - cache.set:
            key: "user:{{ path.id }}"
            value: "{{ redis_user }}"
            ttl: 5m
        - response:
            status: 200
            body: "{{ redis_user }}"
  
  # 第三级：数据库查询
  - sql.query:
      ds: main
      sql: "SELECT * FROM users WHERE id = ?"
      params: { id: "{{ toint(path.id) }}" }
      out: db_user
  
  - branch:
      if: "{{ not db_user }}"
      then:
        - response:
            status: 404
            body: { error: "用户不存在" }
  
  # 更新缓存
  - kv.set:
      ds: redis_cache
      key: "user:{{ path.id }}"
      value: "{{ db_user }}"
      ttl: 24h
  
  - cache.set:
      key: "user:{{ path.id }}"
      value: "{{ db_user }}"
      ttl: 5m
  
  - response:
      status: 200
      body: "{{ db_user }}"
```

### 数据库连接池优化

#### 连接池监控
```yaml
module: monitor
endpoint: db_stats
method: GET
path: /monitor/db/stats
roles: [admin]

steps:
  - plugin.call:
      plugin: db_monitor
      function: connection_pool_stats
      out: pool_stats
  
  - response:
      status: 200
      body: "{{ pool_stats }}"
```

#### 动态连接池调整
```yaml
# 根据负载动态调整连接池大小
- plugin.call:
    plugin: db_optimizer
    function: adjust_pool_size
    params: 
      min_idle: 5
      max_open: 100
      max_lifetime: 300
    out: adjustment_result
```

### 插件性能优化

#### 插件实例池配置
```yaml
plugins:
  registry:
    - name: image_processor
      executable:
        windows: plugins/image_processor.exe
        unix: ./plugins/image_processor
      instances: 4                 # 根据CPU核心数调整
      timeout: 3000
      queueSize: 4096              # 增大队列处理并发
      env:
        CONCURRENCY: 2             # 插件内部并发度
        MEMORY_LIMIT: 512MB
```

#### 插件熔断保护
```yaml
steps:
  - plugin.call:
      plugin: external_service
      function: process_data
      params: { data: "{{ body.data }}" }
      circuit:
        key: "service.process_data"
        threshold: 5               # 5次失败后熔断
        openMs: 30000              # 熔断30秒
        fallback: 
          error: "服务暂时不可用"
          retryAfter: 30
      out: processed_data
```

## 监控与告警

### Prometheus指标监控
```yaml
module: metrics
endpoint: export_metrics
method: GET
path: /metrics

steps:
  - obs.metrics: { out: prometheus_metrics }
  
  - response:
      status: 200
      headers:
        Content-Type: "text/plain; version=0.0.4"
      body: "{{ prometheus_metrics }}"
```

### 自定义性能指标
```yaml
# 接口性能监控
- transform:
    mapping:
      request_start_ms: "{{ now ms }}"

# ... 处理逻辑 ...

- transform:
    mapping:
      request_duration_ms: "{{ sub(now ms, ctx.vars.request_start_ms) }}"

- plugin.call:
    plugin: metrics
    function: record_latency
    params:
      endpoint: "{{ ctx.route.endpoint }}"
      duration_ms: "{{ ctx.vars.request_duration_ms }}"
      status: "{{ ctx.response.status }}"
```

### 性能告警配置
```yaml
# 性能阈值告警
- plugin.call:
    plugin: alert_manager
    function: check_performance
    params:
      metric: "api_latency_ms"
      value: "{{ ctx.vars.request_duration_ms }}"
      threshold: 1000             # 1秒阈值
      severity: "warning"
```

## 调试与问题排查

### SQL调试输出
```yaml
steps:
  - sql.query:
      ds: main
      sql: "SELECT * FROM orders WHERE user_id = ? AND status = ?"
      params: 
        user_id: "{{ path.user_id }}"
        status: "pending"
      out: orders
  
  - response:
      status: 200
      headers:
        X-SQL-Debug: "{{ ctx.vars.sql_log }}"  # 输出SQL调试信息
      body: "{{ orders }}"
```

### 请求追踪
```yaml
# 添加请求追踪ID
- transform:
    mapping:
      trace_id: "{{ uuid }}"

- response:
    status: 200
    headers:
      X-Trace-Id: "{{ ctx.vars.trace_id }}"
      X-Response-Time: "{{ ctx.vars.request_duration_ms }}ms"
    body: "{{ response_data }}"
```

## 性能测试报告

### 生成性能测试报告
```yaml
module: performance
endpoint: test_report
method: POST
path: /performance/test/report
roles: [admin]

request:
  body:
    test_type: { type: string, enum: ["load", "stress", "endurance"] }
    duration: { type: integer, description: "测试时长(秒)" }
    concurrent_users: { type: integer, description: "并发用户数" }

steps:
  - plugin.call:
      plugin: performance_tester
      function: run_test
      params: 
        type: "{{ body.test_type }}"
        duration: "{{ body.duration }}"
        users: "{{ body.concurrent_users }}"
      out: test_results
  
  - response:
      status: 200
      body: "{{ test_results }}"
```

## 最佳实践

### 测试最佳实践
1. **分层测试**：单元测试 → 集成测试 → 性能测试
2. **真实数据**：使用生产环境类似的数据量进行测试
3. **渐进加压**：从低并发开始，逐步增加负载
4. **监控指标**：测试时监控系统资源使用情况

### 优化最佳实践
1. **瓶颈分析**：使用 profiling 工具识别性能瓶颈
2. **缓存策略**：合理使用多级缓存减少数据库压力
3. **异步处理**：耗时的操作使用异步或批处理
4. **连接复用**：优化数据库和外部服务连接复用

### 监控最佳实践
1. **关键指标**：监控响应时间、错误率、吞吐量
2. **资源使用**：监控CPU、内存、磁盘IO、网络IO
3. **告警设置**：设置合理的性能阈值告警
4. **日志分析**：分析日志识别性能问题和优化点

## 下一步学习

完成性能优化与测试后，继续学习：[部署与运维](../第四阶段/04-部署运维.md)