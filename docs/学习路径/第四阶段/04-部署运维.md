# 部署与运维管理

## 部署方式

### 1. 二进制文件部署

#### 编译生产版本
```bash
# 编译Linux生产版本
GOOS=linux GOARCH=amd64 go build -o api-server ./cmd/server

# 编译Windows生产版本  
go build -o api-server.exe ./cmd/server

# 添加版本信息编译
go build -ldflags "-X main.version=1.0.0 -X main.buildTime=$(date +'%Y-%m-%d_%H:%M:%S')" -o api-server ./cmd/server
```

#### 生产环境目录结构
```
/app/
├── api-server          # 可执行文件
├── configs/            # 配置文件目录
│   ├── project.yaml   # 主配置文件
│   ├── interfaces/    # 接口配置目录
│   └── hooks/         # 钩子配置目录
├── plugins/            # 插件目录
├── storage/            # 文件存储目录
├── logs/               # 日志目录
└── .env                # 环境变量文件
```

### 2. Docker容器化部署

#### Dockerfile 示例
```dockerfile
FROM golang:1.21-alpine AS builder

WORKDIR /app
COPY . .

# 安装依赖并编译
RUN apk add --no-cache gcc musl-dev
RUN go build -ldflags "-s -w" -o api-server ./cmd/server

# 生产镜像
FROM alpine:3.18

WORKDIR /app

# 安装运行时依赖
RUN apk add --no-cache ca-certificates tzdata

# 复制编译好的二进制文件
COPY --from=builder /app/api-server .
COPY --from=builder /app/configs ./configs

# 创建必要的目录
RUN mkdir -p plugins storage logs

# 设置环境变量
ENV TZ=Asia/Shanghai
ENV ENV=production

# 暴露端口
EXPOSE 8080

# 启动应用
CMD ["./api-server"]
```

#### docker-compose.yml 示例
```yaml
version: '3.8'

services:
  api-server:
    build: .
    ports:
      - "8080:8080"
    environment:
      - ENV=production
      - TZ=Asia/Shanghai
    volumes:
      - ./configs:/app/configs
      - ./plugins:/app/plugins
      - ./storage:/app/storage
      - ./logs:/app/logs
    restart: unless-stopped
    networks:
      - app-network

  # MySQL数据库
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MYSQL_DATABASE: ${DB_NAME}
      MYSQL_USER: ${DB_USER}
      MYSQL_PASSWORD: ${DB_PASSWORD}
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - app-network
    restart: unless-stopped

  # Redis缓存
  redis:
    image: redis:7-alpine
    command: redis-server --requirepass ${REDIS_PASSWORD}
    volumes:
      - redis-data:/data
    networks:
      - app-network
    restart: unless-stopped

networks:
  app-network:
    driver: bridge

volumes:
  mysql-data:
  redis-data:
```

### 3. Kubernetes部署

#### Deployment配置
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api-server
  labels:
    app: api-server
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api-server
  template:
    metadata:
      labels:
        app: api-server
    spec:
      containers:
      - name: api-server
        image: your-registry/api-server:1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: ENV
          value: "production"
        - name: DB_DSN
          valueFrom:
            secretKeyRef:
              name: api-secrets
              key: db-dsn
        volumeMounts:
        - name: config-volume
          mountPath: /app/configs
        - name: plugins-volume
          mountPath: /app/plugins
        - name: storage-volume
          mountPath: /app/storage
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: config-volume
        configMap:
          name: api-config
      - name: plugins-volume
        emptyDir: {}
      - name: storage-volume
        persistentVolumeClaim:
          claimName: api-storage-pvc
```

#### Service配置
```yaml
apiVersion: v1
kind: Service
metadata:
  name: api-service
spec:
  selector:
    app: api-server
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
```

## 运维管理

### 1. 日志管理

#### 日志配置
```yaml
# configs/project.yaml
logging:
  level: "info"
  format: "json"
  output: "stdout"
  file:
    path: "logs/api.log"
    maxSize: 100
    maxBackups: 7
    maxAge: 30
```

#### 日志格式示例
```json
{
  "timestamp": "2023-12-01T10:30:45Z",
  "level": "info",
  "msg": "接口请求处理完成",
  "module": "users",
  "endpoint": "create_user", 
  "method": "POST",
  "path": "/api/users",
  "status": 201,
  "duration_ms": 45.2,
  "request_id": "req_123456"
}
```

### 2. 监控与告警

#### Prometheus监控配置
```yaml
# 监控接口配置
module: metrics
endpoint: prometheus_metrics
method: GET
path: /metrics

steps:
  - obs.metrics: { out: metrics_data }
  - response:
      status: 200
      headers:
        Content-Type: "text/plain; version=0.0.4"
      body: "{{ metrics_data }}"
```

#### 关键监控指标
- **接口请求数**: `api_requests_total`
- **接口响应时间**: `api_request_duration_seconds`
- **错误率**: `api_errors_total`
- **数据库连接数**: `db_connections_total`
- **插件调用次数**: `plugin_calls_total`

### 3. 备份与恢复

#### 配置备份策略
```bash
#!/bin/bash
# backup.sh

# 备份配置文件
tar -czf /backup/configs-$(date +%Y%m%d).tar.gz configs/

# 备份插件目录  
tar -czf /backup/plugins-$(date +%Y%m%d).tar.gz plugins/

# 上传到云存储
aws s3 cp /backup/configs-$(date +%Y%m%d).tar.gz s3://your-bucket/backups/
aws s3 cp /backup/plugins-$(date +%Y%m%d).tar.gz s3://your-bucket/backups/

# 清理旧备份
find /backup -name "*.tar.gz" -mtime +7 -delete
```

#### 数据库备份
```yaml
# 数据库备份接口
module: admin
endpoint: db_backup
method: POST
path: /admin/db/backup
roles: [admin]

steps:
  - plugin.call:
      plugin: db_backup
      function: backup
      params: 
        database: "main"
        output: "/backup/db-backup-$(date +%Y%m%d).sql"
      out: backup_result
  - response:
      status: 200
      body: "{{ backup_result }}"
```

## 高可用部署

### 1. 负载均衡配置

#### Nginx配置示例
```nginx
upstream api_servers {
    server api1:8080;
    server api2:8080;
    server api3:8080;
    keepalive 32;
}

server {
    listen 80;
    server_name api.yourdomain.com;

    # 健康检查
    location /health {
        proxy_pass http://api_servers/health;
        access_log off;
    }

    location / {
        proxy_pass http://api_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # 超时设置
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }
}
```

### 2. 数据库高可用

#### MySQL主从复制
```yaml
# 主数据库配置
datasources:
  sql:
    main:
      driver: mysql
      dsn: ${DB_MASTER_DSN}
      maxOpenConns: 20

    # 从数据库读取
    read_replica:
      driver: mysql  
      dsn: ${DB_REPLICA_DSN}
      maxOpenConns: 10
      readOnly: true
```

#### 读写分离配置
```yaml
# 写操作使用主数据库
steps:
  - sql.exec:
      ds: main
      sql: "INSERT INTO users (name, email) VALUES (?, ?)"
      params: ["{{ body.name }}", "{{ body.email }}"]

# 读操作使用从数据库
steps:
  - sql.query:
      ds: read_replica
      sql: "SELECT * FROM users WHERE id = ?"
      params: ["{{ path.id }}"]
```

## 安全加固

### 1. 网络安全
- 使用HTTPS加密传输
- 配置防火墙规则
- 启用WAF防护
- 限制管理接口访问IP

### 2. 应用安全
- 定期更新依赖库
- 启用安全头部
- 配置CORS策略
- 实施输入验证和输出编码

### 3. 数据安全
- 数据库连接加密
- 敏感数据加密存储
- 定期安全审计
- 访问日志监控

## 故障排查

### 1. 常见问题排查

#### 服务无法启动
```bash
# 检查端口占用
netstat -tlnp | grep 8080

# 检查配置文件语法
go run ./cmd/server --check-config

# 查看详细错误信息
./api-server --log-level=debug
```

#### 接口访问异常
```yaml
# 调试接口配置
module: debug
endpoint: config_check
method: GET
path: /debug/config

steps:
  - admin.lint: { out: lint_results }
  - response:
      status: 200
      body: "{{ lint_results }}"
```

### 2. 性能问题排查

#### 性能分析接口
```yaml
module: admin
endpoint: performance_profile
method: GET
path: /admin/performance
roles: [admin]

steps:
  - plugin.call:
      plugin: profiler
      function: profile
      params: { duration: "30s" }
      out: profile_data
  - response:
      status: 200
      body: "{{ profile_data }}"
```

## 下一步学习

完成部署与运维管理后，您已经掌握了生产环境部署的所有知识。接下来可以学习故障排查与问题解决：

[故障排查与FAQ](../第四阶段/05-故障排查.md)