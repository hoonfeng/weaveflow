# 第二阶段：认证与权限控制

## 3.1 认证机制概述

配置化API框架支持多种认证方式，确保接口安全：
- **JWT认证**：基于Token的无状态认证
- **API Key + HMAC**：基于密钥和签名的认证
- **Basic认证**：用户名密码基础认证

## 3.2 JWT认证配置

### 3.2.1 项目级配置
在 `configs/project.yaml` 中配置JWT参数：

```yaml
security:
  jwt:
    secret: ${JWT_SECRET:your-super-secret-key}
    issuer: ${JWT_ISSUER:your-app}
    audience: ${JWT_AUDIENCE:your-app-users}
    expiresIn: ${JWT_EXPIRES_IN:24h}
    refreshExpiresIn: ${JWT_REFRESH_EXPIRES_IN:168h}
```

### 3.2.2 接口级配置
在接口配置中启用JWT认证：

```yaml
module: users
endpoint: admin_list
method: GET
path: /api/admin/users
auth: jwt
roles: ["admin"]
permissions: ["users.read", "users.manage"]
```

### 3.2.3 请求示例
```bash
# 获取JWT Token
curl -X POST http://localhost:8080/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"password"}'

# 使用Token访问受保护接口
curl -X GET http://localhost:8080/api/admin/users \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

## 3.3 API Key + HMAC认证

### 3.3.1 接口配置
```yaml
module: payments
endpoint: create_payment
method: POST
path: /api/payments
auth: apikey
```

### 3.3.2 签名计算流程
```bash
# 生成请求签名
TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
NONCE=$(uuidgen)
BODY='{"amount":100,"currency":"USD"}'
BODY_HASH=$(echo -n "$BODY" | sha256sum | cut -d' ' -f1)

MESSAGE="POST\n/api/payments\n$TIMESTAMP\n$NONCE\n$BODY_HASH"
SIGNATURE=$(echo -n "$MESSAGE" | openssl dgst -sha256 -hmac "your-hmac-secret" -binary | base64 | tr '+/' '-_' | tr -d '=')
```

### 3.3.3 请求示例
```bash
curl -X POST http://localhost:8080/api/payments \
  -H "Content-Type: application/json" \
  -H "X-Api-Key: your-api-key" \
  -H "X-Timestamp: $TIMESTAMP" \
  -H "X-Nonce: $NONCE" \
  -H "X-Signature: $SIGNATURE" \
  -d "$BODY"
```

## 3.4 角色与权限控制

### 3.4.1 角色控制
```yaml
# 仅允许管理员角色访问
roles: ["admin"]

# 允许多个角色访问
roles: ["admin", "manager"]

# 允许任一角色访问
roles: "admin"
```

### 3.4.2 权限控制
```yaml
# 需要特定权限
permissions: ["users.read"]

# 需要多个权限
permissions: ["users.read", "users.write"]

# 权限组合控制
permissions: 
  - "users.read"
  - "orders.create"
```

### 3.4.3 细粒度权限示例
```yaml
module: orders
endpoint: view_order
method: GET
path: /api/orders/{id}
auth: jwt
permissions: ["orders.read"]

# 动态权限检查（在步骤中实现）
steps:
  - validate:
      path:
        id: { type: integer, required: true }
  - sql.query:
      ds: main
      sql: "SELECT owner_id FROM orders WHERE id = ?"
      params: ["{{ path.id }}"]
      out: order_info
  - validate:
      # 检查当前用户是否是订单所有者或有管理权限
      expr: |
        {{ ctx.user.id == order_info.owner_id or hasPermission(ctx.user, 'orders.manage') }}
      message: "无权查看此订单"
```

## 3.5 防重放攻击

框架自动提供防重放保护：
- **Nonce检查**：每个请求的X-Nonce必须在有效期内且唯一
- **时间戳验证**：请求时间戳必须在合理时间范围内（通常±5分钟）
- **签名验证**：HMAC签名确保请求完整性

## 3.6 权限声明扫描

使用Admin功能扫描所有接口的权限声明：

```yaml
module: admin
endpoint: permissions_scan
method: GET
path: /api/admin/permissions/scan

steps:
  - admin.permissions_scan:
      out: permissions_list
  - response:
      status: 200
      body: "{{ permissions_list }}"
```

扫描结果包含所有端点的权限要求，可用于：
- 前端权限控制
- 运维权限审计
- 权限文档生成

## 3.7 安全最佳实践

### 3.7.1 JWT安全
- 使用足够长的密钥（至少32字符）
- 设置合理的Token过期时间
- 启用HTTPS传输
- 定期轮换密钥

### 3.7.2 API Key安全
- 定期轮换API Key
- 使用不同密钥区分环境（开发、测试、生产）
- 监控异常API Key使用

### 3.7.3 权限设计
- 遵循最小权限原则
- 定期审计权限分配
- 实现权限回收机制

## 3.8 下一步学习

掌握认证与权限控制后，继续学习：[高级功能概述](../第三阶段/01-高级功能概述.md) 探索文件上传、钩子机制等高级特性。